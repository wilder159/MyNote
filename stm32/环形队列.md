```c
/**
 * @brief ringbuf结构体定义
 */
typedef struct {
    uint8_t *buf;  // 数组头指针
    uint8_t *head; // 队列头指针
    uint8_t *tail; // 队列尾指针
    uint8_t *end;  // 数组尾指针
    uint32_t size; // 环形队列大小
    void *mutex;   // 锁
} core_ringbuf_t;
```

```c
/*** ringbuf start ***/
int32_t core_ringbuf_init(core_ringbuf_t *rbuf, uint32_t size)
{
    if (rbuf->buf) {
        return STATE_AT_ALREADY_INITED;
    }
    memset(rbuf, 0, sizeof(core_ringbuf_t));

    rbuf->buf = os_api->malloc(size);
    if (NULL == rbuf->buf) {
        return STATE_SYS_DEPEND_MALLOC_FAILED;
    }

    rbuf->head = rbuf->buf;
    rbuf->tail = rbuf->buf;
    rbuf->end = rbuf->buf + size;
    rbuf->size = size;

    return STATE_SUCCESS;
}
void core_ringbuf_reset(core_ringbuf_t *rbuf)
{
    rbuf->tail = rbuf->buf;
    rbuf->head = rbuf->buf;
}
// 已经占用空间大小
int32_t core_ringbuf_get_occupy(core_ringbuf_t *rbuf)
{
    uint32_t used = 0;
    if(rbuf->buf == NULL) {
        return 0;
    }

    if (rbuf->tail >= rbuf->head) {
        used = rbuf->tail - rbuf->head;
    } else {
        used = rbuf->tail - rbuf->buf + rbuf->end - rbuf->head;
    }

    return used;
}

int32_t core_ringbuf_write(core_ringbuf_t *rbuf, const uint8_t *data, uint32_t len)
{
    if (len > (rbuf->size - core_ringbuf_get_occupy(rbuf))) {
        return STATE_AT_RINGBUF_OVERFLOW;
    }
    if (rbuf->tail + len >= rbuf->end) {
        uint32_t remain_len = rbuf->end - rbuf->tail;

        memcpy(rbuf->tail, data, remain_len);
        memcpy(rbuf->buf, data + remain_len, len - remain_len);
        rbuf->tail = rbuf->buf + len - remain_len;
    } else {
        memcpy(rbuf->tail, data, len);
        rbuf->tail += len;
    }

    return len;
}

int32_t core_ringbuf_read(core_ringbuf_t *rbuf, uint8_t *data, uint32_t len)
{
    int32_t used = core_ringbuf_get_occupy(rbuf);

    if (len > used) {
        return 0;
    }

    if (rbuf->head + len >= rbuf->end) {
        uint32_t remain_len = rbuf->end - rbuf->head;

        memcpy(data, rbuf->head, remain_len);
        memcpy(data + remain_len, rbuf->buf, len - remain_len);
        rbuf->head = rbuf->buf + len - remain_len;
    } else {
        memcpy(data, rbuf->head, len);
        rbuf->head += len;
    }

    return len;
}
// 销毁队列
void core_ringbuf_deinit(core_ringbuf_t *rbuf)
{
    if (NULL == rbuf) {
        return;
    }

    if (rbuf->buf) {
        os_api->free(rbuf->buf);
    }

    memset(rbuf, 0, sizeof(core_ringbuf_t));
}
/*** ringbuf end ***/
```