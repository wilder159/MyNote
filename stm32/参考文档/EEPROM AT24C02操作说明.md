> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/schips/p/at24cxx.html)

我们这里介绍一下常见的 EEPROM，ATMEL 的 AT24x 系列中的 AT24C02，学会了这个芯片，其他系列的芯片也是类似的。

AT24C02 的存储容量为 2K bit，内容分成 32 页，每页 8Byte (共 256Byte)。

基础概念：

*   存储容量： 存储的总数据量
    
*   页：储存单元的组织方式
    
*   寻址方式：访问元器件的方式，通常计算地址与这个概念有关。
    

寻址方式
----

操作时有两种寻址方式：芯片寻址和片内子地址寻址。

### 芯片寻址

AT24C02 的芯片地址为 1010，其地址控制字格式为`1 0 1 0 A2 A1 A0 R/W`。

> 其中 A2，A1，A0 代表 "可编程地址选择位"。A2，A1，A0 引脚接高 / 低电平后得到确定的三位编码，与 1010 形成 7 位编码，即为该器件的地址码。
> 
> R/W 为芯片读写控制位；该位为 0，表示芯片进行写操作。取决于芯片手册中的定义，通常，W 是低电平有效（0）。
> 
> 有些大容量的芯片，地址组成位包括了`P0`、`P1`等选择位；而这些选择位实际上是 "页选择位"，用来表示内部地址（如下）。但是实际上原理是类似的。

### 片内子地址寻址

芯片寻址可对内部 256 Bytes 中的任一个进行读 / 写操作，其寻址范围为 00~FF，共 256 个寻址单位。

该类器件要通过 I2C 总线操作，读写过程中都要先寻址，这类器件地址由两个字节组成。

如下表，1010 是固定的，A 表示器件地址，可以拉高和拉低，I2C 总线上可以并接 2 的 n 次方个器件。P 表示具体的内部地址数，比如 at24c02 共有 256 个字节，第二个地址字节完全可以满足，不用 P。但是 at24c04 一个有 512 个字节，需要 9 位地址线，第一个字节中的 p 就表示地址线了，p=0 表示低 256 字节，1 表示高 256 字节。

注意：一般页写可以连续写 8 个数据。主机每发送一个字节都要接受从机的应答信号。

该类器件是采用 I2C 总线进行操作的，器件地址根据容量的不同稍有不同，如下：

对于芯片的 A0，A1，A2 脚：（外部引脚用于芯片寻址，当接入多个 IIC 设备时，通过引脚电平不同，可以对多个设备进行读写操作）

*   24C01/02：A0，A1，A2 都是从设备地址。
*   24C04，A1，A2 是从设备地址，A0 变为 P0
*   24C08，A2 是从设备地址，A0，A1 变为 P0、P1
*   24C16 及以上，只有 P0、P1、P2

> 其中，A 表示器件地址，P 表示页地址

在读写的时候首先是：起始条件 + 器件地址

器件地址如上所示在 16k 中，需要两个字节表示内部地址，正是 P 2/1/0 和 8 位具体的地址

![[../../_resources/EEPROM AT24C02操作说明/21425e2100f95584e26c014741eb41a0_MD5.png]]

另外有关于容量的说明：

*   AT24C01：一共 128 页，每页 1 字节，共需 7 位地址数据
    
*   AT24C02：一共 256 页，每页 1 字节，共需 8 位地址数据
    
*   AT24C04：一共 256 页，每页 2 字节，共需 9 位地址数据
    
*   AT24C08：分 4 个块，一共 256 页，每页 4 字节，共需 10 位地址数据
    
*   AT24C16：分 8 块，一共 256 页，每页 8 字节，共需 11 位地址数据
    

在读写的时候要注意，一般在写的时候有页写，在读的时候是连续读，可以设置读取的个数，根据应答和非应答来结束读取。

具体的控制时序省略（关键在于：理解好地址和储存单元的计算关系，结合 I2C 的时序），只是需要注意：

> 在读取 EEPROM 的时候接收到多个数据时，如果不是最后一个数据，单片机要主动发出应答信号，但是接收到最后一个数据后，就不再主动应答，而是等待应答，然后结束条件。

**大 B 与小 b 之间的换算：**

我们常说的 MB、KB 中的 B 都是 Bytes；但有一些储存芯片，它们是以 Bit 作为计量单位的；而 有 `8Bit = 1 Byte`；

因此，小 b 除以 8 即可得到大 B 方式的表示方法。

读写操作时序
------

### 写数据

第一步：首先是 I2C 的起始信号，接着跟上首字节，即 EEPROM 的地址和读写位的组合，读写方向上选择 “写” 操作。

第二步：发送要写入数据的 EEPROM 内部存储地址。

第三步：发送要存储的数据第一个字节、第二个字节… …。

1、写数据 (单片机发送) 过程中，每个字节结束后 EEPROM 都会回应一个“应答位 0”，告诉我们写 EEPROM 成功，如果没有应答表示未成功。

2、写数据过程中，每成功写入一个字节，EEPROM 地址自动加 1，当加到最大值，会溢出。

```
//函数见I2C部分
//向E2PROM中写入一个字节，addr为字节地址
void E2WriteByte(unsigned char addr,unsigned char dat)
{
	I2CStart();
	I2CWrite(0x50<<1);//寻址后选择为写操作
	I2CWrite(addr);	  //写入存储地址
	I2CWrite(dat);
	I2CStop();
}
```

### 读数据

第一步：首先是 I2C 的起始信号，接着跟上首字节，即 EEPROM 的地址和读写位的组合，读写方向上选择 “写” 操作。

第二步：发送要读取的 EEPROM 内部存储地址。

第三步：重新发送 I2C 的起始信号和器件地址，并且在方向位选择 “读” 操作。  
（在这三步中，每一个字节实际上都是在 “写”，因此 EEPROM 都会回应一个 “应答位 0”。）

第四步：读取从器件发回的数据，每读一个字节，如果还想继续读下一个字节，就发送一个 “应答位 0”，如果不想继续读了，就发送一个 “非应答位 1”。

> 应答位： ACK
> 
> 非应答位：NACK

```
//读取E2PROM中一个字节，addr为字节地址
unsigned cahr E2ReadByte(unsigned char addr)
{
	unsigned char dat;
	I2CStart();
	I2CWrite(0x50<<1);
	I2CWrite(addr);
	I2CStart();
	I2CWrite((0x50<<1)|0x01);
	dat=I2CReadNAK();
	I2CStop();
	return dat;
}
```

### 多字节进行读写操作

```
//读取函数，buf为数据指针，addr为E2中的起始地址，len为读取长度
void E2Read(unsigned char *buf,unsigned char addr,unsigned char len)
{
		do{
			I2CStart();
			if(I2CWrite(0x50<<1))
			{
				break;
			}
			I2CStop();
		}while(1);//查询当前是否可以进行读写操作
		I2CWrite(addr);
		I2CStart();
		I2CWrite((0x50<<1)|0x01);
		while(len>1)//连续读取len-1个字节
		{
		   *buf++=I2CReadACK();
		   len--;
		}
		*buf=I2CReadNAK();
		I2CStop();
}
//写入函数，buf为源数据指针，addr为起始地址，len为写入长度
void E2Write(unsigned char *buf,unsigned char addr,unsigned char len)
{
	while(len--)
	{
		do{
			I2CStart();
			if(I2CWrite(0x50<<1))
				break;
			I2CStop();
		} while(1);
		I2CWrite(addr++); 
		I2CWrite(*buf++);
		I2CStop();
	}
}
```

### 页写入功能

一次性写入一页，写完再发送停止位就不用写完一个字节就检测一次

连续向页内写入几个字节后，最后发送停止位  
E2 检测到停止位，将该页写入  
如果数据跨页，则发送一个停止位等待 E2 空闲后，即上一页完全写入非易失区域后，进行下一页的写入

```
void E2Write(unsigned char *buf,unsigned char addr,unsigned char len)
{
	while(len>0)
	{
		do{
			I2CStart();
			if(I2CWrite(0x50<<1))
				break;
			I2CStop();
		} while(1);
		I2CWrite(addr); 
		while(len>0)
		{
			I2CWrite(*buf++);
			len--;
			addr++;
			if((addr&0x07)==0)//检查地址是否到达页边界，每页8字节，固检测第三位即可
				break;
		}
		I2CStop();
	}	
}
```

#### 效率对比

多字节写入和页写入程序都编写出来了，而且页写入的程序我们还特地跨页写的数据，它们的写入时间到底差别多大呢。

我们用一些工具可以测量一下，比如示波器，逻辑分析仪等工具。

我现在把两次写入时间用逻辑分析仪给抓了出来，并且用时间标签 T1 和 T2 标注了开始位置和结束位置，如图所示，右侧显示的 | T1-T2 | 就是最终写入 5 个字节所耗费的时间。

多字节一个一个写入，每次写入后都需要再次通信检测 EEPROM 是否在 “忙”，因此耗费了大量的时间。

同样的写入 5 个字节的数据：

*   一个一个写入用了 8.4ms 左右的时间
*   使用页写入，只用了 3.5ms 左右的时间

![[../../_resources/EEPROM AT24C02操作说明/43d937f7cbe6dfc8107014b3311655cb_MD5.png]]

![[../../_resources/EEPROM AT24C02操作说明/2ec5c77c6b55cf161815cc8457531778_MD5.png]]

附录：关于 IIC-EEPROM 页写问题
---------------------

**结论：**无论从什么地址开始连续写，不能超过（跨过）一整页。

**背景：**

在向 EEPROM 连续写入多个字节的数据时，如果每写一个字节都要等待的话，整体上的写入效率就太低了。因此 EEPROM 的厂商就想了一个办法，把 EEPROM 分页管理。24C01、24C02 这两个型号是 8 个字节一个页，而 24C04、24C08、24C16 是 16 个字节一页。例如 AT24C02，一共是 256 个字节，8 个字节一页，那么就一共有 32 页。

分配好页之后，如果我们在同一个页内连续写入几个字节后，最后再发送停止位的时序。EEPROM 检测到这个停止位后，就会一次性把这一页的数据写到非易失区域，就不需要像上节课那样写一个字节检测一次了，并且页写入的时间也不会超过 5ms。如果我们写入的数据跨页了，那么写完了一页之后，我们要发送一个停止位，然后等待并且检测 EEPROM 的空闲模式，一直等到把上一页数据完全写到非易失区域后，再进行下一页的写入，这样就可以在很大程度上提高数据的写入效率。

**本质：**页写的原理是通过内部写缓冲 RAM 实现的（读操作不需要，可以连续读）。

**详解：**

AT24CXX 系列的 EEPROM 为了提高写效率，提供了页写功能。

内部有个一页大小的写缓冲 RAM（地址范围也就是从 00 到页大小）。

发生写操作时，开始送入的地址对应的页被选中，并将其内容映像到缓冲 RAM，数据从低端地址对应的缓冲 RAM 地址开始修改，超过这个地址范围就回到 00。

写完后，就会把开始确定的 EEPROM 页擦除，再把一整页 RAM 数据写入。所有写数据都发生在开始写地址时确定的页上。

如，页容量为 128，一页都是从 00 开始按 128 字节分成一个个的页；

> 此时，0 页就是 07F，1 页就是 80FF，类推，边界就是 128 字节的整数倍地址。

页 RAM 的地址范围为 7 位 00~7F，写入时高端地址就是页号。

发生写操作，开始送入的地址对应的页被锁存，后续不论写多少，都在这个页中，只是一个**页内的地址进行加一，超过就归零开始**。从 F0 开始写 32 个字节，那么开始送入的地址为 F0，就会锁定在 1 号页（第 2 个页）上，底端 7 位页内部地址开始从 70H 开始写，到达 7F 时回到 00 再到 10H，也就是写在了 F0FF，808F。

也就是，从 01 开始写也只能到 7F，再往 80 写就跑到 00 上去了，这就是写操作的翻卷，datasheet 上都有说明。

就是从边界前写两个字节也要分两次写。页是绝对的，按整页大小排列，不是从开始写入的地址开始算。

> 读没有页的问题，可以从任意地址开始读取任意大小数据，只是超过整个存储器容量时地址才回卷。但一次性访问的数据长度也不要太大。

所以，使用分页的存储器进行储存时，要做好存储管理，尽量同时读写的数据放在一个页上。

ref :

*   [https://blog.csdn.net/weixin_41413511/article/details/99304654](https://blog.csdn.net/weixin_41413511/article/details/99304654)
*   [https://blog.csdn.net/softn/article/details/51857750](https://blog.csdn.net/softn/article/details/51857750)