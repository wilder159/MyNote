> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/m0_73931287/article/details/133210349?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-1-133210349-blog-89290172.235%5Ev43%5Epc_blog_bottom_relevance_base5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ECtr-1-133210349-blog-89290172.235%5Ev43%5Epc_blog_bottom_relevance_base5&utm_relevant_index=2)

一、SVC 异常
--------

SVC(系统服务调用，亦简称系统调用) 用于**产生系统函数的调用请求**。例如，操作系统不让用户程序直接访问硬件，而是通过提供一些系统服务函数，用户程序使用 SVC 发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。

因此，当用户程序想要控制特定的硬件时，它就会产生一个 SVC 异常，然后操作系统提供的 SVC 异常服务例程得到执行，它再调用相关的操作系统函数，后者完成用户程序请求的服务。这种 “提出要求——得到满足” 的方式，很好、很强大、很方便、很灵活、很能可持续发展。

首先，它使用户程序从控制硬件的繁文缛节中解脱出来，而是由 OS 负责控制具体的硬件。

第二， OS 的代码可以经过充分的测试，从而能使系统更加健壮和可靠。

第三，它使用户程序无需在特权级下执行，用户程序无需承担因误操作而瘫痪整个系统的风险。

第四，通过 SVC 的机制，还让用户程序变得与硬件无关，因此在开发应用程序时无需了解硬件的操作细节，从而简化了开发的难度和繁琐度，并且使应用程序跨硬件平台移植成为可能。开发应用程序唯一需要知道的就是操作系统提供的应用编程接口 (API)，并且了解各个请求代号和参数表，然后就可以使用 SVC 来提出要求了。 其实，严格地讲，操作硬件的工作是由设备驱动程序完成的，只是对应用程序来说，它们也是操作系统的一部分，如图所示。

![[../../_resources/Cortex M3 M4之SVC和PendSV异常/dda7b2c711637514b9c83b4c8a249136_MD5.png]]

 SVC 异常通过执行” SVC” 指令来产生。该指令需要一个立即数，充当系统调用代号。 SVC 异常服务例程稍后会提取出此代号，从而解释本次调用的具体要求，再调用相应的服务函数。

> 例如：SVC 0x3 ; 调用 3 号系统服务

在 SVC 服务例程执行后，上次执行的 SVC 指令地址可以根据自动入栈的返回地址计算出。找到了 SVC 指令后，就可以读取该 SVC 指令的机器码，从机器码中萃取出立即数，就获知了请求执行的功能代号。如果用户程序使用的是 PSP， 服务例程还需要先执行 MRSRn,PSP 指令来获取应用程序的堆栈指针。通过分析 LR 的值，可以获知在 SVC 指令执行时正在使用哪个堆栈。

### **二、PendSV 异常**

PendSV（可悬起的系统调用），它和 SVC 协同使用。一方面， SVC 异常是必须立即得到响应的应用程序执行 SVC 时都是希望所需的请求立即得到响应。另一方面， PendSV 则不同，它是可以像普通的[中断](https://so.csdn.net/so/search?q=%E4%B8%AD%E6%96%AD&spm=1001.2101.3001.7020)一样被悬起的（不像 SVC 那样会上访）。 OS 可以利用它 “缓期执行” 一个异常，直到其它重要的任务完成后才执行动作。 悬起 PendSV 的方法是：手工往 NVIC 的 PendSV 悬起寄存器中写 1。 悬起后， 如果优先级不够高，则将缓期等待执行。PendSV 的典型使用场合是在上下文切换时（在不同任务之间切换）。例如，一个系统中有两个就绪的任务，上下文切换被触发的场合可以是：  
1、执行一个系统调用

2、系统滴答定时器（systick）中断（轮转调度中需要）  
举个例子来理解：假设有这么一个系统，里面有两个就绪的任务，并且通过 SysTick 异常启动上下文切换，如下图所示：

![[../../_resources/Cortex M3 M4之SVC和PendSV异常/c1009c7bda39c05025fa5af97578b155_MD5.png]]上图是两个任务轮转调度的示意图。但若在产生 Sys Tick 异常时正在响应一个中断，则 SysTick 异常会抢占其 ISR。在这种情况下， OS 不得执行上下文切换，否则将使中断请求被延迟，而且在真实系统中延迟时间还往往不可预知——任何有一丁点实时要求的系统都决不能容忍这种事。因此，在 CM3/CM4 中也是严禁没商量——如果 OS 在某中断活跃时尝试切入线程模式，将触犯用法 fault 异常，如图所示。

![[../../_resources/Cortex M3 M4之SVC和PendSV异常/eced94c09bb78d763905e5ce4feb413e_MD5.png]]

为解决此问题，早期的 OS 会检测当前是否有中断在活跃中，只有没有任何中断需要响应时，才执行上下文切换（切换期间无法响应中断）。然而，这种方法的弊端在于，它可以把任务切换动作拖延很久 (因为如果抢占了 IRQ，本次 SysTick 在执行后不得作上下文切换，只能等待下一 SysTick 异常），尤其是当某中断源的频率和 Sys Tick 异常的频率比较接近时，会发生 “共振”。现在好了， Pen d SV 来完美解决这个问题了。 Pen d SV 异常会自动延迟上下文切换的请求， 直到其它的 ISR 都完成了处理后才放行。为实现这个机制，需要把 PendSV 编程为最低优先级的异常。如果 O S 检测到某 IRQ 正在活动并且被 SysTick 抢占，它将悬起一个 PendSV 异常， 以便缓期执行上下文切换，如图所示。

![[../../_resources/Cortex M3 M4之SVC和PendSV异常/3a8a782723a39727ba76e01bfbc59daa_MD5.png]]上图中事件的流水账记录如下：

(1) 任务 A 呼叫 SVC 来请求任务切换（例如，等待某些工作完成）  
(2) OS 接收到请求，做好上下文切换的准备，并且 pend 一个 PendSV 异常。  
(3) 当 CPU 退出 SVC 后，它立即进入 PendSV，从而执行上下文切换。  
(4) 当 PendSV 执行完毕后，将返回到任务 B，同时进入线程模式。  
(5) 发生了一个中断，并且中断服务程序开始执行  
(6) 在 ISR 执行过程中，发生 SysTick 异常，并且抢占了该 ISR。  
(7) OS 执行必要的操作，然后 pend 起 PendSV 异常以作好上下文切换的准备。  
(8) 当 SysTick 退出后，回到先前被抢占的 ISR 中， ISR 继续执行  
(9) ISR 执行完毕并退出后， PendSV 服务例程开始执行，并且在里面执行上下文切换。  
(10) 当 PendSV 执行完毕后，回到任务 A，同时系统再次进入线程模式。