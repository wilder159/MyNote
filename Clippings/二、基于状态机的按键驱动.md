> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [aijishu.com](https://aijishu.com/a/1060000000392035)

> 按键作为单片机的输入设备，可以向单片机输入数据、传输命令等，是设置参数和控制设备的常用接口。所以，学会按键驱动也是初学者必不可少的能力。说到按键驱动程序，大家应该也不陌生，而一般的按键驱动流程图如下

![[../_resources/二、基于状态机的按键驱动/8e6a6406255263641051be39b9330456_MD5.png]]  
**【说在前面的话】**

按键作为单片机的输入设备，可以向单片机输入数据、传输命令等，是设置参数和控制设备的常用接口。所以，学会按键驱动也是初学者必不可少的能力。说到按键驱动程序，大家应该也不陌生，而一般的按键驱动流程图如下

![[../_resources/二、基于状态机的按键驱动/109314cbc1490c607cda51aff22b42e1_MD5.png]]

这里，可能有人会问，为什么要延时 10ms 啊？

那是因为按键被按下时，不会像理想的情况非 0 即 1，而是会有抖动，如下图

![[../_resources/二、基于状态机的按键驱动/7c9f64f7b3213d4979417f45a0e29177_MD5.png]]

当机械按键被按下或松开时，会有 10ms 的抖动时间，所以要延时 10ms 来消去波形抖动 (*￣︶￣)

知道了这个，一般初学者编写的按键驱动程序如下：

```
//延时1ms
void Delay1ms() {   //@12.000MHz
  unsigned char i, j;
  i = 12;
  j = 169;
  do{  
    while (--j);
  } while (--i);
}
//ms延时 
void delay_ms(int ms){
  char i = 0;
  for(i = 0; i < ms; i++){
    Delay1ms();  
  }
}
char get_key(){
  //检测按键是否被按下
  if(KEY1 == 0){
    //延时10ms
    delay_ms(10);
    //再次检测按键是否被按下
    if(KEY1 == 0){
      //等待按键松开
      while(KEY1 == 0){ }
      delay_ms(10);
      return 1;  
    }
  }
  return 0;
}
```

像这种按键驱动程序也很简单，作为基础学习和一些简单的系统中还可以，但是在很多的产品设计中，这种按键程序还是有很大的不足和缺陷。因为他不仅采用了软件延时使单片机效率降低而且还在那里死等按键松开，系统的实时性也变得很差。为此，有人提出了**一种基于状态机的按键驱动程序**，很好地解决了上述程序的缺陷。下面我们就简单讲一下什么是状态机。

**【状态机简介】**

对于学电子的同学，首先接触到的状态机应该是在数字逻辑电路（**简称数电**）中，状态机的分析方法被应用于时序逻辑电路的设计中，其实状态机的思想对我们的软件设计也很有用，首先简单介绍一下状态机，它是**由有限的状态**和**相互之间的迁移**构成的。在任何时候，只能处于状态机的某一个状态，当接收到一个转移事件时，状态机进行状态的转移。

下面，就以按键驱动为例，画出他的状态转移图，如下

![[../_resources/二、基于状态机的按键驱动/627303f913f9f9ffc370d831fe9188cc_MD5.png]]

有了状态转移图，那我们就用程序实现一下这个按键驱动程序。从图中我们知道按键驱动程序由 3 个状态，刚好可以用 C 语言的 switch     case 语句来实现这 3 个状态，而状态间的迁移就可以用 if 条件判断语句来实现。知道了这个，那我们就动手实现一下。

**基于状态机的按键驱动程序**

首先，打开原理图，看一下按键接到了单片机的哪个管脚，如下

![[../_resources/二、基于状态机的按键驱动/6b76871dd2cfa4aa066f53d7496df9df_MD5.png]]

我们以按键 1 为例，接到了单片机的 P33 脚，当按键**按下时为低电平**，**松开为高电平**，基于此我们的按键程序如下：

```
sbit KEY1 = P3^3;//key1
char get_key(){
  //保存按键状态
  static char key_flag = 0;
  //软件延时计时器
  static unsigned int s_Counter = 0;
  switch(key_flag){
    //状态0为无按键按下
    case 0:
      if(KEY1 == 0){
        //如果有按键按下，转为状态1
        key_flag = 1;
      }
      break;
     //状态1为延时消抖  
    case 1:
      s_Counter++;
      if(s_Counter > 1000){
        //延时10ms，计时器清零
        s_Counter = 0;
        if(KEY1 == 0){
          //如果按键被按下，转为状态2
          key_flag = 2;
          return 1;
        }else{
          //如果按键未按下，转为状态0
          key_flag = 0;
        }
      }
      break;
     //状态2为等待按键释放  
    case 2:
      if(KEY1 == 1){
        //如果按键松开，转为状态0
        key_flag = 0;
      }
      break;  
  }
  return 0;
}
```

*   注意，每个 case 结束后都有一个 break
*   第 18 行，s_Counter \> 1000 相当于延时 10ms，当然这个 1000 是随便给的值，大家要根据具体情况设置此值，如果测试小于 10ms 就可以加大此值，我们只是为了说明用 s_Counter 可以延时。
*   第 24 行，在延时去抖完成后就返回了 1（相当于按键按下），这样做的好处就是可以提高按键响应速度。当然也可以在状态 2 按键松开后返回 1。

基于状态机的按键驱动程序我们就简单写完了，相信大家也 get 到重点了，这个只是简单实现了按键的单击，当然，我们也可以实现按键的双击和长按。  
![[../_resources/二、基于状态机的按键驱动/38fd622f4d0f726eb689785c2ddb2278_MD5.png]] 
哈哈，在编写驱动之前，我们先细化一下需求，首先区分单击和长按，这个很简单，规定一个时间就可以，我们定为 1 秒钟。即按下时间小于 1 秒为单击，大于 1 秒为长按。

那双击怎么办呢？

我们规定，当第一次按下持续时间小于 500ms 内松开按键，在之后 500ms 内又按下按键，此时为双击事件。这里有两点需要注意，1、第一次按下的时间不能超过 500ms，否则就被判断为单击或长按。2、在第一次按下松开后开始计时，如果 500ms 内没有按键再次按下则为单击。按键双击的原理如下图所示

![[../_resources/二、基于状态机的按键驱动/f3b50f5de012d171bf8a1081675afa74_MD5.png]]

按键双击和长按的需求我们讲完了，接下来画出他的状态转移图，如下

![[../_resources/二、基于状态机的按键驱动/1bb282402f024d54a904a64b9450784b_MD5.png]]

![[../_resources/二、基于状态机的按键驱动/ed9430b2c55b16e21cda8e6e130fcb80_MD5.png]]

哈哈哈，还可以吧，没那么复杂。相信大家应该能看懂。这里有必要说一下状态 5，判断双击其实就是第二次按下延时 10ms 消抖，如果确实按下则为双击否则为单击。好了，看看程序怎么实现吧，如下

```
#define DELAY_10ms   500
#define DELAY_500ms   10000
char get_key3(){
  static char key_flag = 0;
  static unsigned int s_Counter = 0;
  switch(key_flag){
    case 0://无按键按下
      if(KEY1 == 0){
        key_flag = 1;
      }
      break;
    case 1://延时10ms消抖
      s_Counter++;
      if(s_Counter > DELAY_10ms){
        s_Counter = 0;
        if(KEY1 == 0){
          key_flag = 2;
        }else{
          key_flag = 0;
        }
      }
      break;
    case 2://计时500ms,等待按键松开
      s_Counter++;
      if(s_Counter > DELAY_500ms){//500ms内按键未松开
        s_Counter = 0;  
        key_flag = 6;
      }
      if(KEY1 == 1){//500ms内按键松开
        s_Counter = 0;  
        key_flag = 3;
      }
      break;
    case 3://按键松开，延时10ms消抖
      s_Counter++;
      if(s_Counter > DELAY_10ms){
        s_Counter = 0;  
        key_flag = 4;
      }
    break;
    case 4://等待双击
      s_Counter++;
      if(s_Counter > DELAY_500ms){
        s_Counter = 0;
        key_flag = 7;//500ms内按键未按下
      }
      if(KEY1 == 0){//500ms内按键被按下
        s_Counter = 0;
        key_flag = 5;
      }
    break;
    case 5://延时10ms消抖
      s_Counter++;
      if(s_Counter > DELAY_10ms){
        s_Counter = 0;        
        if(KEY1 == 0){
          key_flag = 8;//等待按键松开      
          return 2;//双击
        }else{          
          key_flag = 7;//单击
        }
      }
    break;    
    case 6:
      s_Counter++;
      if(s_Counter > DELAY_500ms){
        s_Counter = 0;  
        key_flag = 8;//等待按键松开      
        return 3;//长按
      }
      if(KEY1 == 1){
        s_Counter = 0;  
        key_flag = 7;
      }
    break;
    case 7://单击
      key_flag = 8;
      return 1;//单击
      break;
    case 8://等待按键松开      
      if(KEY1 == 1){
        s_Counter = 0;  
        key_flag = 0;        
      }
    break;  
  }
  return 0;
}
```

*   在开头定义了延时 10ms 和 500ms 的宏
*   用返回值代表不同的按键事件，返回 1 为单击，返回 2 为双击，返回 3 为长按
*   这里**提醒**大家按键在**按下和松开时记得延时消抖**

怎么样，双击和长按是不是很简单，接下来的彩蛋也很精彩哦。

![[../_resources/二、基于状态机的按键驱动/f173490c80765b115b33eec558bda7d8_MD5.png]]

今天的彩蛋环节依然是对上面的代码进行化简，使其变得更简洁和优雅。在简化之前，我们要在讲一个知识点，那就是**子状态机**。顾名思义，就是我们可以把上面的复杂状态机（包含 8 个状态的状态机）拆成多个简单的状态机，而拆开的每一个状态机就是一个**子状态机**。

这个概念是懂了，那怎么把上面的状态机拆开呢？

哈哈，这个就需要在 “双击” 事件中做文章，大家可以这样想，双击其实就是两次单击，只不过两次单击的间隔时间小于 500ms 而已。基于此，我们就可以先用一个子状态机来区分单击和长按，然后再用一个状态机来区分双击，这样我们就把上面的复杂状态机拆成了两个状态机了。

![[../_resources/二、基于状态机的按键驱动/6e6db680a3142cdd39086c09637b549e_MD5.png]]

可能这样说，大家还是不太明白，那我们就直接画出状态转移图，如下，是一个区分短按和长按的子状态机

![[../_resources/二、基于状态机的按键驱动/3cbc49ca40679b4e671bf973da7aec47_MD5.png]]

有了状态转移图，程序也很简单，如下

```
#define DELAY_1000ms   20000
unsigned int  get_key_short_or_long(){
  static char key_flag = 0;
  static unsigned int s_Counter = 0;
  switch(key_flag){
    case 0://无按键按下
      if(KEY1 == 0){
        s_Counter = 0;
        key_flag = 1;
      }
      break;
    case 1://延时10ms消抖
      s_Counter++;
      if(s_Counter > DELAY_10ms){
        s_Counter = 0;
        if(KEY1 == 0){
          key_flag = 2;
        }else{
          key_flag = 0;
        }
      }
      break;  
    case 2://计时1000ms,
      s_Counter++;
      if(s_Counter > DELAY_1000ms){//大于1000ms为长按
        key_flag = 3;//等待按键松开      
        return s_Counter;//长按
      }
      if(KEY1 == 1){//小于1000ms为短按
        key_flag = 0;
        return s_Counter;//短按
      }
      break;
    case 3://等待按键松开      
      if(KEY1 == 1){        
        key_flag = 0;        
      }
    break;      
  }
  return 0;
}
```

*   在状态 2 中，我们判断是长按还是短按，大于 1000ms 为长按，否则为短按
*   **注意**，我们这次返回的是计数器 s_Counter 的值，这个是为了方便之后判断是不是双击（第一次单击持续时间小于 500ms 要等待双击事件）

![[../_resources/二、基于状态机的按键驱动/43c07cbc584ef99e7f0b840db1203c50_MD5.png]]

好，接下来我们就看看程序怎么判断是双击的，如下

```
char get_key4(){
  static char key_flag = 0;
  static unsigned int s_Counter = 0;
  unsigned int key_time = 0;
  key_time = get_key_short_or_long();
  switch(key_flag){
    case 0:
      if(key_time >= DELAY_1000ms){
        return 3;
      }else if(key_time >= DELAY_500ms){
        return 1;
      }else if(key_time > 0){
        s_Counter = 0;
        key_flag = 1;
      }
      break;
    case 1://等待双击
      s_Counter++;
      if(s_Counter > DELAY_500ms){        
        key_flag = 0;
        return 1;
      }
      if(key_time > 0){
        key_flag = 0;
        return 2;
      }
      break;
  }    
}
```

*   由于只有 2 个状态，而且都很简单，所以没有画它的状态转移图
*   在状态 0 中，我们根据 key_time 来判断长按还是短按，如果大于 1 秒为长按，返回 3；如果大于 500ms 小于 1s 为单击返回 1；如果按下的时间小于 500ms，就转为状态 1，等待双击。
*   在状态 1 中，我们等待 500ms，如果时间到了还没有按键按下则返回 1，如果有按键按下（key_time 大于 0 小于 500ms），则为双击返回 2

> 作者：FledgingSu 支离苏  
> 文章来源：[嵌入式小书虫](https://aijishu.com/link?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FH2hpuQBwNxUHELvTQTLebA)

**推荐阅读**

*   [Native Memory Tracking 详解（4）: 使用 NMT 协助排查内存问题案例](https://aijishu.com/a/1060000000391824)
*   [Native Memory Tracking 详解（3）: 追踪区域分析 (二)](https://aijishu.com/a/1060000000391591)
*   [Native Memory Tracking 详解（2）: 追踪区域分析 (一)](https://aijishu.com/a/1060000000391094)

> 欢迎大家点赞留言，更多 Arm 技术文章动态请关注极术社区[嵌入式客栈](https://aijishu.com/blog/qianrushikezhan)专栏欢迎添加极术小姐姐微信（id:aijishu20) 加入技术交流群，请备注研究方向。