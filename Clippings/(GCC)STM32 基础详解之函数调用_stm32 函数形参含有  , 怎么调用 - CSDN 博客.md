> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.csdn.net](https://blog.csdn.net/qwe5959798/article/details/122717894)

介绍不再赘述，接上一篇：

[内存分配](https://blog.csdn.net/qwe5959798/article/details/122562894?spm=1001.2014.3001.5502 "内存分配")

本文会分析一个简单的普通函数调用和中断函数调用。其中涉及 [Cortex-M3](https://so.csdn.net/so/search?q=Cortex-M3&spm=1001.2101.3001.7020) 架构与 AAPCS 相关知识。但并不打算从 Cortex-M3 寄存器组开始讲起，相关知识请参考文末参考资料。

函数调用就一句话：**有调有还，再调不难**

1. 起始代码
-------

```
void fun(unsigned int tmp)
{
  if(tmp)
  {
  }
}
 
int main(void)
{
  unsigned int tmp1 = 0x11111111;
  fun(tmp1);
  while (1)
  {
 
  }
}
```

2. 普通函数调用过程分析
-------------

很多东西在上一章都有提到，就不在详细展开，直接上汇编代码分析过程：

```
void fun(unsigned int tmp)
{
// 08000224   PUSH           {R7}
// 08000226   SUB            SP, SP, #12
// 08000228   ADD            R7, SP, #0
// 0800022A   STR            R0, [R7, #4]
  if(tmp)
  {
  }
}
// 0800022C   NOP
// 0800022E   ADDS           R7, #12
// 08000230   MOV            SP, R7
// 08000232   POP            {R7}
// 08000234   BX             LR
 
int main(void)
{
// 08000236   PUSH           {R7, LR}
// 08000238   SUB            SP, SP, #8
// 0800023A   ADD            R7, SP, #0
  unsigned int tmp1 = 0x11111111;
    //  0800023C   MOV.W          R3, #0x11111111
    //  08000240   STR            R3, [R7, #4]
  fun(tmp1);
    //  08000242   LDR            R0, [R7, #4]
    //  08000244   BL             fun                           ; 0x08000224
  while (1)
    //  08000248   B              0x08000248                    ; <main>+0x12
  {
 
  }
}
```

首先，需要明白的是，main 函数也是由其他代码块所调用，它只是我们应用代码的源头，而不并不是整个系统代码的源头。由上一章我们知道，Cortex-M3 架构整个系统代码的源头是在地址 0x0000 0004 处保存的指令地址，这是由 M3 架构规定的。而 main 函数被调用是在. s 启动文件里：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/227963ae1ef977da99c0e6b311548885_MD5.png]]

**BL main** 

这条指令有两个动作**，**即跳转到 main 这个符号所代表地址处，**同时把当前位置的下一条指令地址保存在 LR**。这样，在 main 函数结束时，可以使用 **B LR** 或者 **BX LR** 可以跳转到被调用前的下一条指令处执行。可以看到这里 main 这个符号所代表的地址为 0x0800 0236，这里正是 main 函数第一条指令所在 FLASH 地址：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/07656d9d240028ae04becc9685e4e778_MD5.png]]

首先看一下进入 main 之后所有寄存器的状态：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/eb14f27bf9a8490e853b5869a29c4ef5_MD5.png]]

根据 ARM 架构过程调用标准中描述：R0~R3 是调用者用来传递参数的，如果超过 4 个，则保存在栈中，而 R4~R11 则用作保存变量 (R9 在不同架构下，使用作用不同)，最后的返回结果由 R0 和 R1 保存。

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/90d926d4b1a0ccc8d124f01b03bbbdf0_MD5.png]]

所以，调用 main 函数的过程中，我们只需要保证那些在调用前可能会被使用的 “**工具**” 调用前是什么样调用后还是什么样，就能保证程序在调用 main 函数后，还能继续准确无误的执行。专业说法叫，**还原现场**。这里有两个问题：

1. 调用前哪些 “**工具**” 可以使用？

所有通用寄存器 (M3 架构中是 R0~R12)、栈。

2. 哪些需要还原？

首先 ARM 规定了 R0~R3 被用作传参，R0~R1 在返回时被用来保存结果，调用者需要确保这 4 个寄存器在调用后可以被随意使用，所以无论有没有传递参数，只要调用者在调用前使用了这 4 个寄存器，调用者都需要把使用的寄存器入栈，调用后出栈，所以被调用者不需要关心这 4 个寄存器。而 R4~R11 是用来保存变量的寄存器，R12 是用来保存 IP 的寄存器，ARM 规定了被调用函数要确保这些寄存器被调用前是什么，被调用后还是什么样。栈也是一样。最后 LR 保存有调用处的下一条指令，所以为了能顺利跳转回去，要确保这个值在函数结束时还能被重新加载回来。

3. 怎么还原这些 “**工具**”？

寄存器用前入栈，用后出栈。不破坏【大于调用时 SP 指针地址】处的数据，且 SP 指针保证调用前后不变，即栈还原。

所以调用后要保证 R4~R12 和 LR、SP 调用前一样。(其实 LR 未必要一样，只是在调用后通常都使用 BX LR 直接跳转回去，因为调用时的 BL 会自动加载 LR 的值)

main 函数内容如下：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/0e8784edc40791b50f7185d14012f952_MD5.png]]

**PUSH ｛R7 , LR｝**

这条指令也有两个动作，即把 R7 和 LR 寄存器里面的内容保存到栈里，并且 SP 指针减去保存内容所占用的栈的大小。而保存位置就由栈顶指针 SP 开始。

对 main 函数来说，它调用过程中使用了 R7 和 LR，所以这两个寄存器的值会被改变，所以为了使 main 函数在运行完成后，跳转回被调用处时，运行现场被完美还原，必须要把它们先保存起来，等到 R7 和 LR 被使用完，在函数结束的时候，再把保存的值填充回去，这个上文已经说明。

执行完这条指令通过 debug 模式下可以看到 R7 和 LR 的值正是被保存在从 SP(0x2001 0000) 开始的栈内：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/57303ab53db3cc94bf588a2c15626fb9_MD5.png]]

 而 R13~R15 变为了：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/204bde539153b035a554d659dd668a13_MD5.png]]

对比入栈前的数值，SP 减小了 8，而栈地址 0x2000 FFFC 和 0x2000 FFF8 处分别保存的是 LR 和 R7 的值。(你应该知道 SP 永远指向当前栈顶，PC 永远指向将要执行的代码地址，但 SP 需要手动调整，或者使用 PUSH 这种带有自动调整的指令，而 PC 无需手动调整，如果手动更改 PC 值，将会改变代码执行流程)

**SUB        SP , SP , #8**

**ADD        R7 , SP , #0**

这两句是令 SP = SP - 8 , R7 = SP + 0。首先 SP = SP - 8 是为了保存临时变量。但是这里我们知道 main 里只用一个 tmp1 变量，而它占用了 4 个字节，那为何需要减 8？

1.SP 减 8 获得调用 fun 前的栈底，它同时又是 main 调用的 fun 函数的栈顶，也是调用 fun 返回后的栈顶。

2. 在标准调用中，需要保证 SP8 字节对齐。

**MOV.W        R3 , #0x11111111**

**STR             R3 , [R7 , #4]**

**LDR             R0 , [R7 , #4]**

**BL                fun**

上述代码是作用是令 R3 = 0x11111111，然后把 R3 的值保存到 R7 的值 + 4 地址处，也就是 main 的栈底 + 4，然后又把此处的值加载到 R0 里面，然后跳转到 fun 函数。由上文知道 R0~R3 是用来传递参数的，所以最后把 0x11111111 加载到 R0 是没有任何问题的，但是总感觉代码很绕很罗嗦，这个和优化等级有关，因为现在是默认没有任何优化，所以每个步骤都不会被省略，包括每个变量保存在栈里。

在跳转到 fun 函数后我们查看寄存器：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/2b60bfbccb1a116943b983ea492b1bb0_MD5.png]]

R0 用来传递参数值是 0x11111111，其次 SP 是当前栈顶，也就是 fun 如果需要使用栈，是从 0x2000FFF0 开始的，LR 因为 BL  fun 这条代码，自动装载了 main 函数调用 fun 处的下一句代码：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/80c8640620da853f9912915659c46c4f_MD5.png]]

这里最低位置 1 表示 THUMB 状态。查看栈可以看到：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/996bee16bc8849a5bbe4f0c9e2d4b0f4_MD5.png]]

如果 fun 需要使用栈保存一个 32 位变量，它会被保存在 0x2000FFEC 处。对于 fun 函数内容如下：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/420c2a7a14d5a9f8dc9782260bd54018_MD5.png]]

可以看到因为字节对齐，除了 push 自动分配的 4 字节，又手动分配了 12 字节 (0x2000FFE8~0x2000FFE0)，但其实只用了 4 字节 (0x2000FFE4)：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/6832cf5169f8a4bdef32337685244cc9_MD5.png]]

但是因为对 tmp 判断后什么也没做，所以只有一个 nop，而且直接把 SP 增加 12 后，用 pop 把 R7 复原的同时 SP 又增加 4。运行到最后就是 fun 中使用的 R7 在使用过后被复原了，SP 指针在使用完后又变为 main 的栈底：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/5800994278f2517a985d19e8509dd3f3_MD5.png]]

至此，main 调用 fun 之前的现场又被还原。 

当然例子中的 fun 函数如此简单，但是在更加复杂的情况下也是一样，使用哪个寄存器保存哪个寄存器，以保证调用结束时复原，比如这里的 R7。同时 SP 保证调用前和调用后相同。如果有返回值，则使用 R0~R1 保存。(当你使用汇编写代码时，则可以随心所欲。但是当你汇编与 C 混合编程时则需遵守)

3. 中断函数调用过程分析
-------------

在中断例程中我们使用 HardFault，方法是故意触发一个异常。例程代码如下：

```
void HardFault_Handler(void)
{
// 08000224   PUSH           {R7}
// 08000226   ADD            R7, SP, #0
  while(1)
    //  08000228   B              0x08000228                    ; <HardFault_Handler>+0x4
  {
    
  }
}
char *str = "1234";
void fun(unsigned int tmp)
{
// 0800022C   PUSH           {R7}
// 0800022E   SUB            SP, SP, #12
// 08000230   ADD            R7, SP, #0
// 08000232   STR            R0, [R7, #4]
  if(tmp)
    //  08000234   LDR            R3, [R7, #4]
    //  08000236   CMP            R3, #0
    //  08000238   BEQ            0x08000242                    ; <fun>+0x16
  {
    str[0] = 1;
    //  0800023A   LDR            R3, =str                      ; [PC, #16] [0x0800024C] =0x20000000
    //  0800023C   LDR            R3, [R3]
    //  0800023E   MOVS           R2, #1
    //  08000240   STRB           R2, [R3]
  }
}
// 08000242   NOP
// 08000244   ADDS           R7, #12
// 08000246   MOV            SP, R7
// 08000248   POP            {R7}
// 0800024A   BX             LR
// 08000250   PUSH           {R7, LR}
 
int main(void)
{
// 08000250   PUSH           {R7, LR}
// 08000252   SUB            SP, SP, #8
// 08000254   ADD            R7, SP, #0
  unsigned int tmp1 = 0x11111111;
    //  08000256   MOV.W          R3, #0x11111111
    //  0800025A   STR            R3, [R7, #4]
  fun(tmp1);
    //  0800025C   LDR            R0, [R7, #4]
    //  0800025E   BL             fun                           ; 0x0800022C
  while (1)
    //  08000262   B              0x08000262                    ; <main>+0x12
  {
 
  }
}
```

可以看到在 fun 中判断 tmp 非 0 后会改变一个常量字符串，为了编译通过，没有在对 * str 加以 const 修饰。从汇编代码看，在运行完以下代码后会触发 HardFault 中断：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/e32d71e17a7214e951e1244e95f1c5ee_MD5.png]]

也就是把 R2 的值存入 R3 所存地址里，因为 R3 所存地址是不可改变区域，所以会触发一个异常。进入中断前各寄存器值为：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/81433c2a9e312939a720eddb8dc90adf_MD5.png]]

而在进入中断后，首先有两个位被置 1：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/f7e821cfc5954690775d63b0fa104cd9_MD5.png]]

第一个是代表硬 fault：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/2bf2cede6a2fca8d4692a62d9dc92d11_MD5.png]]

第二个表示不精确的数据访问：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/0c502e0e871c77a5fa7a9c55eb756a84_MD5.png]]

当然如果是普通中断，比如串口中断是不会有这些置位的。

根据《Cortex-M3 权威指南》中断响应分为 3 个步骤：

**1. 入栈**

由上文触发异常前的 SP 我们可知在进入异常后的栈顶为 0x2000FFE0，当进入异常后，我们查看栈空间：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/206eb4082bcccd719a491aa47beaef12_MD5.png]]

可以看到地址从 0x2000FFDC 开始，逐渐递减依次保存着 xPSR, PC, LR, R12 以及 R3‐R0，这是固定的：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/b7e209db083d87ab8d946de03c679974_MD5.png]]

**2. 取向量**

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/181bc3b9a388858899b28ca8a23bb84f_MD5.png]]

这点因为代码已经进入到我们在 main.c 中声明的 HardFault_Handler 函数内，足以证明取向量是正常的，因为 3 号异常正是 HardFault_Handler。 

**3. 更新寄存器**

在进入异常处理函数后，各个寄存器的值如下： 

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/2bb4f39f212998d1fcdb449bf384d7a9_MD5.png]]

其中 SP 因自动压栈而减小，LR 的值表示：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/12429e3d5be8fd330019d8feaae900e4_MD5.png]]

最后 PSR 的最低位表示异常编号：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/055ea551482357dc5dcc8889d1ee3965_MD5.png]]

至于其他寄存器，和普通函数调用并无不同，使用哪个入栈哪个，在中断结束时则出栈。在寄存器方面异常处理比普通函数调用多的就是自动压栈和自动出栈 [R0~R3\R12\LR\PC\PSR]。但是可以想到异常处理和普通函数并不冲突，因为自动出入栈的这些寄存器在普通函数调用中并不会被使用。

最后是中断返回，这里因为是硬 fault，所以是没有返回的，但是在其他异常中，返回时需要：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/a15a41c1c8c2d4cf7bf418f2f32a284a_MD5.png]]

结尾：

思考如何从 hardfault 中分析触发函数，如果是多层嵌套呢？

更新：2022-02-10
-------------

1. 关于 AAPCS 简单介绍，截取自《ARM Cortex-M3 与 Cortex-M4 权威指南》：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/06312dbc323f09465e5f89556a23afc4_MD5.png]]

2. 关于函数结构：

![[../_resources/(GCC)STM32 基础详解之函数调用_stm32 函数形参含有  , 怎么调用 - CSDN 博客/3acd80c881c465a13a5e24536ac14e52_MD5.png]]

 此处可以印证于前文函数汇编代码。

拓展：
---

[x86 下 C 语言函数调用栈](https://www.cnblogs.com/clover-toeic/p/3755401.html "x86下C语言函数调用栈")