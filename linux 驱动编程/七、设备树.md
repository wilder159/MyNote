设备树是一种描述硬件资源的数据结构，它通过bootloader将硬件资源传给内核，使得内核和硬件资源描述相对独立
为啥要有设备树，平台总线每换一块板子，就要修改C文件，还要重新编译，在内核和源码中留下大量板级细节代码，内核源码会越来越大，
Device Tree （DT）设备树
FDT 展开设备树
Device Tree Source (dts)设备树源码
Device Tree Source include 更通用的设备树代码
Device Tree blob （dtb）编译后的设备树
dtc 设备树编译器
设备树从根节点开始，每个设备都是一个节点。根节点就相当于树根。节点和节点之间可以互相嵌套，
形成父子关系。可以理解为树枝可以分成好几个小的树枝。设备的属性用 key-value 对(键值对)来描述，每
个属性用分号结束，如下
```c
/{ //根节点
   node1//子节点 node1
   {
   };
    node2//子节点 node2
   {
   };
  };
```
格式：<名称>[@<设备地址>]
<名称>节点的名称也不是任意起的，一般要体现设备的类型而不是特点的型号，比如网口，应该命名为
ethernet，而不是随意起一个，比如 111。
<设备地址>就是用来访问该设备的基地址。但并不是说在操作过程中来描述一个地址，他主要用来区分用。
- 同一级的节点只要地址不一样，名字是可以不唯一的。
- 设备地址是一个可选选项，可以不写。但为了容易区分和理解，一般是都写的。
举例：\
     uart8: serial@02288000
其中，uart8 就是这个节点名称的别名，serial@02288000 就是节点名称。\
一般我往一个节点里面添加内容的时候，不会直接把添加的内容写到节点里面，而是通过节点的引用来添加。
举例
     &uart8 {
           pinctrl-names = "default";
           pinctrl-0 = <&pinctrl_uart8>;
           status = "okay";
       };
&uart8 表示引用节点别名为 uart8 的节点，并往这个节点里面添加以下内容：
           pinctrl-names = "default";
            pinctrl-0 = <&pinctrl_uart8>;
           status = "okay";
注意事项：
编译设备树的时候，相同的节点的不同属性信息都会被合并，相同节点的相同的属性会被重写，使用
引用可以避免四处找节点。如 dts 和 dtsi 里面都有根节点，但最终会合并成一个根节点。设备树基本属性
**address-cells** **和** **size-cells** **属性**
**reg** **属性**
**compatible 属性 ：**
设备树中的每个表示一个设备的节点都需要一个 compatible 属性，compatible 属性是操作系统用来决
定设备和驱动绑定的关键因素。compatible 属性也叫做兼容性属性，属性的值是一个字符串列表，用于表
示是何种设备，可以在代码中进行匹配。
**status 属性**  
status 属性用来表示节点的状态，其实就是硬件的状态